{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE FlexibleContexts #-}
module Yarn.Control where
--module Yarn.Control (
--    -- * Delaying
--    delay,
--    -- * Switching
--    switchWhen,
--    (-->),
--    (>--),
--    (-@>),
--    -- * Chaining
--    chainWhen
--) where
--
--import Yarn.Core
--import Yarn.Event
--
----------------------------------------------------------------------------------
---- Using feedback and recursive Yarn.
----------------------------------------------------------------------------------
--delay :: Monad m => a -> Yarn m a a
--delay a = valYarn $ \a' -> Output a (delay a')
----------------------------------------------------------------------------------
---- Switching Yarn arbitrarily.
----------------------------------------------------------------------------------
---- | Acts as `w1` until `p` evaluates true on the output of `sw`, then acts
---- as `w2`.
---- To switch from `pure 3` to `pure 4` after 4 seconds:
---- @
---- switchWhen (at 4) isJust
----   (pure 3) (pure 4)
---- @
--switchWhen :: Monad m
--           => Yarn m a c  -- ^ the switching wire.
--           -> (c -> Bool) -- ^ The switching predicate.
--           -> Yarn m a b  -- ^ The initial wire.
--           -> Yarn m a b  -- ^ the wire switched to.
--           -> Yarn m a b
--switchWhen sw p w1 w2 = chainWhen sw p w1 (const w2)
--
----------------------------------------------------------------------------------
---- Chaining (Knitting?) Yarn.
----------------------------------------------------------------------------------
---- | Acts as `w1` until `p` evaluates true on the output of `sw`, then
---- feeds `fw` the last output of `w1` to produce the new Yarn. This allows
---- a second Yarn to start up where the last one left off.
--chainWhen :: Monad m
--          => Yarn m a c         -- ^ The switching wire.
--          -> (c -> Bool)        -- ^ The switching predicate.
--          -> Yarn m a b         -- ^ The initial wire.
--          -> (b -> Yarn m a b)  -- ^ A function to generate the next wire.
--          -> Yarn m a b
--chainWhen = chainWhen' Nothing
--    where chainWhen' Nothing sw p w fw = Yarn $ \dt a -> do
--              Output !b w'  <- stepYarn w dt a
--              Output !c sw' <- stepYarn sw dt a
--              if p c
--                then stepYarn (fw b) dt a
--                else return $ Output b $ chainWhen' (Just b) sw' p w' fw
--          chainWhen' (Just b) sw p w fw = Yarn $ \dt a -> do
--              Output !c sw' <- stepYarn sw dt a
--              if p c
--                then stepYarn (fw b) dt a
--                else do Output !b' w'  <- stepYarn w dt a
--                        return $ Output b' (chainWhen' (Just b') sw' p w' fw)
